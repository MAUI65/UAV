[
  {
    "objectID": "Gstreamer/gst_valve.html",
    "href": "Gstreamer/gst_valve.html",
    "title": "Gstreamer Python Bindings",
    "section": "",
    "text": "# ---\n# skip_showdoc: true\n# ---\n\n\nDefault parameters\nsee the code below\n\n\nCode\nfrom dataclasses import dataclass\n\n@dataclass\nclass DefaultParams():\n    camera_dev = \"CAM-0\"\n    cameras = {\n        \"CAM-0\": {\n            \"gst\": [\n                'videotestsrc pattern=smpte is-live=true ! tee name=t ',\n                't. ! queue leaky=2 ! videoconvert ! videorate drop-only=true ! video/x-raw,framerate=10/1,format=(string)BGR ! videoconvert ! appsink emit-signals=true  sync=false async=false  max-buffers=2 drop=true ',\n                't. ! queue leaky=2 ! valve name=myvalve drop=true ! video/x-raw,format=I420,width=640,height=480 ! videoconvert ! x264enc ! rtph264pay ! udpsink host=127.0.0.1 port=5000',\n                ],\n            \"udp\": True,\n            \"host\": \"127.0.0.1\",\n            \"port\": 5000,\n        },\n        \"CAM-1\": {\n            \"gst\": [\n                'videotestsrc pattern=ball is-live=true ! tee name=t ',\n                't. ! queue leaky=2 ! videoconvert ! videorate drop-only=true ! video/x-raw,framerate=10/1,format=(string)BGR ! videoconvert ! appsink emit-signals=true  sync=false async=false  max-buffers=2 drop=true ',\n                't. ! queue leaky=2 ! valve name=myvalve drop=true ! video/x-raw,format=I420,width=640,height=480 ! videoconvert ! x264enc ! rtph264pay ! udpsink host=127.0.0.1 port=5000',\n                ],\n            \"udp\": True,\n            \"host\": \"127.0.0.1\",\n            \"port\": 5000,\n        },\n        \"CAM-2\": {\n            \"gst\": [\n                'videotestsrc pattern=snow is-live=true ! tee name=t ',\n                't. ! queue leaky=2 ! videoconvert ! videorate drop-only=true ! video/x-raw,framerate=10/1,format=(string)BGR ! videoconvert ! appsink emit-signals=true  sync=false async=false  max-buffers=2 drop=true ',\n                't. ! queue leaky=2 ! valve name=myvalve drop=true ! video/x-raw,format=I420,width=640,height=480 ! videoconvert ! x264enc ! rtph264pay ! udpsink host=127.0.0.1 port=5000',\n                ],\n            \"udp\": True,\n            \"host\": \"127.0.0.1\",\n            \"port\": 5000,\n        },\n        \"CAM-3\": {\n            \"gst\": [\n                'videotestsrc pattern=pinwheel is-live=true ! tee name=t ',\n                't. ! queue leaky=2 ! videoconvert ! videorate drop-only=true ! video/x-raw,framerate=10/1,format=(string)BGR ! videoconvert ! appsink emit-signals=true  sync=false async=false  max-buffers=2 drop=true ',\n                't. ! queue leaky=2 ! valve name=myvalve drop=true ! video/x-raw,format=I420,width=640,height=480 ! videoconvert ! x264enc ! rtph264pay ! udpsink host=127.0.0.1 port=5000',\n                ],\n            \"udp\": True,\n            \"host\": \"127.0.0.1\",\n            \"port\": 5000,\n            },\n    \n       }\n\n    # socket address and port\n    mqqt_address='127.0.0.1'\n    src_port=1234\n\n\n\n\n\nDefaultParams\n\n DefaultParams ()\n\nDefaultParams.cameras[\"CAM-0\"][\"gst\"] is a list of gstreamer commands.\n\nprint(DefaultParams.cameras[\"CAM-0\"])\n\n{'gst': ['videotestsrc pattern=smpte is-live=true ! tee name=t ', 't. ! queue leaky=2 ! videoconvert ! videorate drop-only=true ! video/x-raw,framerate=10/1,format=(string)BGR ! videoconvert ! appsink emit-signals=true  sync=false async=false  max-buffers=2 drop=true ', 't. ! queue leaky=2 ! valve name=myvalve drop=true ! video/x-raw,format=I420,width=640,height=480 ! videoconvert ! x264enc ! rtph264pay ! udpsink host=127.0.0.1 port=5000'], 'udp': True, 'host': '127.0.0.1', 'port': 5000}\n\n\nThe default parameters list 4 gst videotestsrc each with a different pattern. The patterns are: - smpte, ball, snow, pinwheel.\nThe video is split with a tee into two streams 1. is streamed via an on / off valve to udp port 5000. 2. is streamed to an appsink for processing.\n\n\nGstreamer pipeline\n\n\nCode\nclass GstVideoStream():\n    \"Video streamer class using gstreamer\"\n    def __init__(self, gstcommand:List  # gst command list\n                 , address:str='127.0.0.1'  # udp address\n                 , port:int=5000): # udp port\n        Gst.init(None)\n        self.gstcommand = gstcommand\n        self.address = address\n        self.port = port\n\n        self.latest_frame = self._new_frame = None\n        self.video_pipe = None\n        self.video_sink = None\n        self.pause = False\n        self.run()\n\n    def start_gst(self, config=None):\n        \"\"\" Start gstreamer pipeline and sink\n        \"\"\"\n        command = ' '.join(self.gstcommand)\n        print(command)\n        self.video_pipe = Gst.parse_launch(command)\n        self.video_pipe.set_state(Gst.State.PLAYING)\n        self.video_sink = self.video_pipe.get_by_name('appsink0')\n\n    @staticmethod\n    def gst_to_opencv(sample):\n        \"Transform byte array into np array\"\n\n        buf = sample.get_buffer()\n        caps_structure = sample.get_caps().get_structure(0)\n        array = np.ndarray(\n            (\n                caps_structure.get_value('height'),\n                caps_structure.get_value('width'),\n                3\n            ),\n            buffer=buf.extract_dup(0, buf.get_size()), dtype=np.uint8)\n        return array\n\n    def frame(self):\n        \"\"\" Get Frame\n        Returns:\n            np.ndarray: latest retrieved image frame\n        \"\"\"\n        if self.frame_available:\n            self.latest_frame = self._new_frame\n            # reset to indicate latest frame has been 'consumed'\n            self._new_frame = None\n        return self.latest_frame\n\n    # def frame_available(self):\n    #     \"\"\"Check if a new frame is available\n    #     Returns:\n    #         bool: true if a new frame is available\n    #     \"\"\"\n    #     return self._new_frame is not None\n\n    def run(self):\n        \"\"\" Get frame to update _new_frame\n        \"\"\"\n\n        self.start_gst()\n        try:\n            self.video_sink.connect('new-sample', self.callback)\n        except:\n            pass\n\n    def callback(self, sink):\n        sample = sink.emit('pull-sample')\n        # if not self.pause:\n        self._new_frame = self.gst_to_opencv(sample)\n\n        return Gst.FlowReturn.OK\n\n\n\n\n\nGstVideoStream\n\n GstVideoStream (gstcommand:List, address:str='127.0.0.1', port:int=5000)\n\nVideo streamer class using gstreamer\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ngstcommand\nList\n\ngst command list\n\n\naddress\nstr\n127.0.0.1\nudp address\n\n\nport\nint\n5000\nudp port\n\n\n\n\n\n\nGstVideoStream.frame_available\n\n GstVideoStream.frame_available ()\n\nCheck and return frame is available\n\n\nValve gives the ability to pause the video stream\n\n\n\nset_valve_state\n\n set_valve_state (pipeline:gi.repository.Gst.Pipeline, valvename:str,\n                  drop_state:bool)\n\nSet the state of a valve element\n\n\n\n\nType\nDetails\n\n\n\n\npipeline\nPipeline\nset up by Gst.parse_launch(command)\n\n\nvalvename\nstr\nname of valve element\n\n\ndrop_state\nbool\nTrue = drop frames\n\n\n\n\n\n\ntoggle_valve_state\n\n toggle_valve_state (pipeline:gi.repository.Gst.Pipeline, valvename:str)\n\nToggle the state of a valve element\n\n\n\n\nType\nDetails\n\n\n\n\npipeline\nPipeline\nset up by Gst.parse_launch(command)\n\n\nvalvename\nstr\nname of valve element\n\n\n\n\n\n\nping_ip\n\n ping_ip (ip_address:str)\n\nPing an IP address to see if it is in use\n\n\n\n\nType\nDetails\n\n\n\n\nip_address\nstr\nIP address to ping\n\n\nReturns\nbool\nreturns True if IP address is in use\n\n\n\nTest ping IP\n\ntest_eq(ping_ip(\"127.0.0.1\"), True)\n\n\ntest_eq(ping_ip(\"1.2.3.4\"), False)\n\n\n\n\nMqtt\n\n Mqtt (camera:str, video:__main__.GstVideoStream)\n\nClass to control the valve via MQTT\n\n\n\n\nType\nDetails\n\n\n\n\ncamera\nstr\nname of camera\n\n\nvideo\nGstVideoStream\nvideo object\n\n\n\n\n\nMain function for local testing\n\n\nCode\ndef main(camera=\"CAM-0\"):\n    params = DefaultParams()\n    cv2.namedWindow(camera, cv2.WINDOW_NORMAL)\n    gstcommand = params.cameras[camera][\"gst\"]\n    video = GstVideoStream(gstcommand)\n    mqtt = Mqtt(camera, video)\n\n    print('Initialising stream...')\n    waited = 0\n    while not video.frame_available():\n        waited += 1\n        print('\\r  Frame not available (x{})'.format(waited), end='')\n        cv2.waitKey(30)\n\n    print('\\nSuccess!\\nStarting streaming - press \"q\" to quit.')\n\n    wait_time = 1\n    count = 0\n    while True:\n\n        if video.frame_available() and count % 10 == 0:\n            frame = video.frame().copy()\n            # # cv2.putText(frame, f'{frame_num:2d} {data_received}', (10, 30), cv2.FONT_HERSHEY_PLAIN, 1, (0, 0, 255), 2)\n            frame = resize(frame, width= 600)\n            cv2.imshow(camera, frame)\n            pass\n\n\n        if count % 1000 == 0:\n            print( count)\n        count += 1\n\n\n        k = cv2.waitKey(wait_time)\n\n        if k == ord('q') or k == ord('Q') or k == 27:\n            break\n\n        if k == ord('v'):\n            # Assuming you have a valve element named 'myvalve' in your pipeline\n            valve = video.video_pipe.get_by_name(\"myvalve\")\n            current_drop_state = valve.get_property(\"drop\")\n            print(\"current_drop_state\", current_drop_state)\n            valve.set_property(\"drop\", not current_drop_state)\n            current_drop_state = valve.get_property(\"drop\")\n            print(\"new_drop_state\", current_drop_state)\n\n            time.sleep(2)\n\n            # video.video_pipe.set_state(Gst.State.PLAYING)\n\n        if k == ord(' '):\n            if wait_time != 0:\n                wait_time = 0\n            else:\n                wait_time = 1\n\n        if k == ord('s'):\n            save = 0\n            save_path = Path(params.save_path) \n            save_path.mkdir(exist_ok=True)\n            pass\n\n    mqtt.close()\n\n\n\n\n\nmain\n\n main (camera='CAM-0')\n\n\n\nReceive on UDP with this Test :\nfrom first terminal run\n   gst-launch-1.0 udpsrc port=5000 ! application/x-rtp,encoding-name=H264,payload=96 ! \\\n           rtph264depay ! h264parse ! queue ! avdec_h264 ! xvimagesink sync=false async=false -e\nfrom second terminal run\n  mosquitto_pub -m \"CAM-0\" -t \"STREAM-CAMERA\"\n  mosquitto_pub -m \"CAM-1\" -t \"STREAM-CAMERA\"\n\n\nTest with two cameras from terminal\n\n\nCode\n# from multiprocessing import Process   # you will need to import Process from multiprocessing\n\ntry: __name__\nexcept NameError: __name__ = None   # stops nbdev_preview from forever looping / crashing\nif __name__ == '__main__':\n    \n    cams = []\n    params = DefaultParams()\n    for cam in list(params.cameras.keys())[:2]:\n        print(cam)\n        p = Process(target=main, args=(cam,))\n        p.start()\n        cams.append(p)\n\n    for p in cams:\n        p.join()\n\n\nCAM-0\nCAM-1\nvideotestsrc pattern=ball is-live=true ! tee name=t  t. ! queue leaky=2 ! videoconvert ! videorate drop-only=true ! video/x-raw,framerate=10/1,format=(string)BGR ! videoconvert ! appsink emit-signals=true  sync=false async=false  max-buffers=2 drop=true  t. ! queue leaky=2 ! valve name=myvalve drop=true ! video/x-raw,format=I420,width=640,height=480 ! videoconvert ! x264enc ! rtph264pay ! udpsink host=127.0.0.1 port=5000videotestsrc pattern=smpte is-live=true ! tee name=t  t. ! queue leaky=2 ! videoconvert ! videorate drop-only=true ! video/x-raw,framerate=10/1,format=(string)BGR ! videoconvert ! appsink emit-signals=true  sync=false async=false  max-buffers=2 drop=true  t. ! queue leaky=2 ! valve name=myvalve drop=true ! video/x-raw,format=I420,width=640,height=480 ! videoconvert ! x264enc ! rtph264pay ! udpsink host=127.0.0.1 port=5000\nConnecting to Connecting to   127.0.0.1\n127.0.0.1\nInitialising stream...\nInitialising stream...\nSuccess!\nStarting streaming - press \"q\" to quit.\n\n\nSuccess!\nStarting streaming - press \"q\" to quit.\n0\n0\n1000\nClosed mqtt client\nClosed mqtt client"
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "class Card:\n    \"A playing card\"\n\n    def __init__(self,\n                 suit: int,  # An index into `suits`\n                 rank: int):  # An index into `ranks`\n        self.suit, self.rank = suit, rank\n    # def __str__(self): return f\"{ranks[self.rank]}{suits[self.suit]}\"\n    # __repr__ = __str__\n\n\n@patch\ndef __eq__(self: Card, a: Card): return (self.suit, self.rank) == (a.suit, a.rank)\n\n\n@patch\ndef __lt__(self: Card, a: Card): return (self.suit, self.rank) &lt; (a.suit, a.rank)\n\n\n@patch\ndef __gt__(self: Card, a: Card): return (self.suit, self.rank) &gt; (a.suit, a.rank)\n\n@patch\ndef eq(self: Card, a: Card):\n    return (self.suit, self.rank) == (a.suit, a.rank)\n\n\n\nsay_gday\n\n say_gday (greeting:str=\"G'day\", strine:bool=True, dropbears:bool=False)\n\nSays g’day, the classic Aussie greeting\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ngreeting\nstr\nG’day\nGreeting to use\n\n\nstrine\nbool\nTrue\nUse incomprehensible Aussie accent?\n\n\ndropbears\nbool\nFalse\nAlso warn about drop-bears?\n\n\n\n\n\nMarkdown for Jupyter notebooks cheatsheet\ncheatsheet\n\n\nMake a requirements.txt file\nIt is used to scan your imports and build a Python requirements file for you. It is a good idea to run this command after you have finished your notebook and before you commit your changes to source control.\npip install pipreqs\npipreqs --force --mode gt ."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "UAV",
    "section": "",
    "text": "documentation is available at UAV docs"
  },
  {
    "objectID": "index.html#guide-to-developing-uav",
    "href": "index.html#guide-to-developing-uav",
    "title": "UAV",
    "section": "Guide to developing UAV",
    "text": "Guide to developing UAV\n\nInitial setup\nFor a step-by-step guide to using nbdev guide to using nbdev You’ll need the following software to develope using nbdev:\n\nPython venv\nA Python package manager: ie pip\nJupyter Notebook\n\npip install jupyter\n\nnbdev\n\npip install nbdev\n\nQuarto\n\nnbdev_install_quarto\n\nInstall Quarto JupyterLab extension\n\npip install jupyterlab-quarto\n\nInstall nbdev pre-commit hooks to catch and fix uncleaned and unexported notebooks\n\npip install pre-commit\nsee nbdev Pre-Commit Hooks for more details\n\n\nBuild the library\npip install UAV\n\n\nPreview Docs\nStart the preview by entering this into your terminal:\nnbdev_preview\n\n\nPrepare your changes\nBefore commiting your changes to GitHub we recommend running nbdev_prepare in the terminal,\nwhich bundles the following commands:\n\nnbdev_export: Builds the .py modules from Jupyter notebooks\nnbdev_test: Tests your notebooks\nnbdev_clean: Cleans your notebooks to get rid of extreanous output for git\nnbdev_readme: Updates your repo’s README.md file from your index notebook.\n\n\n\nPush to GitHub\nYou can now commit and push your changes to GitHub. As we mentioned before, always remember to run nbdev_prepare before you commit to ensure your modules are exported and your tests pass. You can use git status to check which files have been generated or changed. Then:\ngit add .\ngit commit -m 'Add `say_hello`; update index' # Update this text with your own message\ngit push\nThis will kick-off your GitHub Actions. Wait a minute or two for those to complete, then check your updated repo and documentation."
  },
  {
    "objectID": "index.html#other",
    "href": "index.html#other",
    "title": "UAV",
    "section": "Other",
    "text": "Other\n\nSet up autoreload\nSince you’ll be often updating your modules from one notebook, and using them in another, it’s helpful if your notebook automatically reads in the new modules as soon as the Python file changes. To make this happen, just add these lines to the top of your notebook:\n%load_ext autoreload\n%autoreload 2"
  }
]