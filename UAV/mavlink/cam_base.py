# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/api/20_mavlink.cam_base.ipynb.

# %% auto 0
__all__ = ['SYSTEM_GCS_CLIENT_ID', 'SYSTEM_CAM_ID', 'MavLinkBase']

# %% ../../nbs/api/20_mavlink.cam_base.ipynb 9
import logging
logging.getLogger("uav").setLevel(logging.INFO)
logging.root.setLevel(logging.INFO)
import cv2

import numpy as np
from imutils import resize

import threading
import time
from pymavlink import mavutil
from pymavlink.dialects.v20 import common as mavlink2
import threading

import UAV.params as params
from ..imports import *   # TODO why is this relative import on nbdev_export?
import UAV
# gi.require_version('Gst', '1.0')

# %% ../../nbs/api/20_mavlink.cam_base.ipynb 14
SYSTEM_GCS_CLIENT_ID = 195
SYSTEM_CAM_ID = 2   # 1 = vehicle, 195 = companion computer but here i use 2 for debugging
class MavLinkBase:
    """
    Mavlink Camera Base 
    """
    def __init__(self, connection_string, # "udpin:localhost:14550"
                 baudrate=57600, #baud rate of the serial port
                 mav_type=mavutil.mavlink.MAV_TYPE_CAMERA, # type used in heartbeat
                 is_server=True, # server or client
                 debug=False, # logging level
                 ):
        self._log = logging.getLogger("uav.{}".format(self.__class__.__name__))
        if debug:
            log_level = logging.DEBUG
        else:
            log_level = logging.INFO
        self._log.setLevel(log_level)
        self.connection_string = connection_string
        self.baudrate = baudrate
        # self.gstpipes = gstpipes
        # self.mav_type = mav_type
        
        self.init_extras(mav_type, is_server)  # Needs to be implemented in child class
        self.start_mavlink()
    

    def init_extras(self, mav_type, is_server):
        """ This is called from init() and can be used to set up additional parameters
            It models a mavlink Client. Can  be implemented in child class
            copy and change these as needed, consider call super().init_extras() first 
            https://mavlink.io/en/messages/common.html#MAV_COMPONENT
            """
        self.mav_type=mav_type  
        if is_server:
            self.log.info(f"init_extras() for Server, mav_type: {mav_type}") 
            self.source_system=SYSTEM_CAM_ID # source system   1 = vehicle, 195 = companion computer
            self.source_component=mavutil.mavlink.MAV_COMP_ID_CAMERA # source component https://mavlink.io/en/messages/common.html#MAV_COMPONENT
            self.target_system=SYSTEM_GCS_CLIENT_ID # source system   1 = vehicle, 195 = companion computer
            self.target_component=mavutil.mavlink.MAV_COMP_ID_USER1 # target component
            # self.target_component=0 # target component
            self.do_heartbeat=True   # send heartbeat
            self.do_listen=True   # listen for commands
            self.do_ack = True   # send ack

        else:  # client
            self.log.info(f"init_extras() for Client, mav_type: {mav_type}")   
            self.source_system=SYSTEM_GCS_CLIENT_ID # source system   1 = vehicle, 195 = companion computer
            self.source_component=mavutil.mavlink.MAV_COMP_ID_USER1 # source component
            self.target_system=SYSTEM_CAM_ID # target system   1 = vehicle, 195 = companion computer
            self.target_component=mavutil.mavlink.MAV_COMP_ID_CAMERA # target component
            # self.target_component=0 # target component
            self.do_heartbeat=True   # send heartbeat
            self.do_listen=False   # listen for commands
            self.do_ack = False   # send ack

    def start_mavlink(self):
        """Start the MAVLink connection."""
        # Create the connection  Todo add source_system and component options
        self.log.info("Starting MAVLink connection...")

        self.master = mavutil.mavlink_connection(self.connection_string, # "udpin:localhost:14550"
                                                 baud=self.baudrate, # baud rate of the serial port
                                                 source_system=int(self.source_system), # source system
                                                 source_component=int(self.source_component), # source component
                                                 dialect="ardupilotmega", # dialect
                                                 )
        self.master.target_system = self.target_system
        self.master.target_component = self.target_component
        # self.log.info(f"Mavlink Dialect: {self.master.dialect}")
        self.log.info(f"Source system: {self.master.source_system}, Source component: {self.master.source_component}")
        self.log.info(f"Target system: {self.master.target_system}, Target component: {self.master.target_component}")
        self.log.info(f"see https://mavlink.io/en/messages/common.html#MAV_COMPONENT")
         
        if self.do_heartbeat:
            self._t_heartbeat = threading.Thread(target=self.send_heartbeat, daemon=True)
            self._t_heartbeat.start()
        if self.do_listen:
            self._t_mav_listen = threading.Thread(target=self.listen, daemon=True)
            self._t_mav_listen.start()
            
    def __str__(self) -> str:
        return self.__class__.__name__

    def __repr__(self) -> str:
        return "<{}>".format(self)

    @property
    def log(self) -> logging.Logger:
        return self._log
    
    def send_heartbeat(self):
        """Send a heartbeat message to indicate the server is alive."""
        self._t_heartbeat_stop = False
        self.log.info("Starting heartbeat")
        while not self._t_heartbeat_stop:
            self.master.mav.heartbeat_send(
                self.mav_type,  # type
                # mavutil.mavlink.MAV_TYPE_ONBOARD_CONTROLLER,
                mavutil.mavlink.MAV_AUTOPILOT_INVALID,  # autopilot
                0,  # base_mode
                0,  # custom_mode
                mavutil.mavlink.MAV_STATE_ACTIVE,  # system_status
                3  # MAVLink version
            )
            # print("Cam heartbeat_send")
            time.sleep(1)  # Send every second

    def send_ack(self, msg):
        """Send an ACK message to indicate a command was received."""
        self.log.debug(f"Sending ACK target_system:{self.target_system} target_component:{self.target_component}")
        self.master.mav.command_ack_send(
                    msg.command,
                    mavutil.mavlink.MAV_RESULT_ACCEPTED,  # or other MAV_RESULT enum
                    # todo enabling these causes QGC not to show them
                    0,  # progress
                    0,  # result_param2
                    self.target_system,  # target_system
                    self.target_component,  # target_component

        )
        

    def listen(self):
        """Listen for MAVLink commands and trigger the camera when needed."""
        self._t_mav_listen_stop = False
        self.log.info("Listening for MAVLink commands...")
        while not self._t_mav_listen_stop:
            # Wait for a MAVLink message
            try:
                msg = self.master.recv_match(blocking=True, timeout=1)
                if msg is None:
                    continue
                if msg.get_type() == 'COMMAND_LONG':
                    self.log.debug(f"Received message {msg.command}")
                    if self.do_ack:
                        self.send_ack(msg)
                        
                if msg.get_type() == 'COMMAND_ACK':
                    self.log.debug(f" func listen() Received ACK ")
                # elif msg.get_type() == 'HEARTBEAT':
                #     self.log.debug(f"Received HEARTBEAT ")
                # elif msg.get_type() == 'STATUSTEXT':
                #     self.log.debug(f"Received STATUSTEXT ")
                # elif msg.get_type() == 'CAMERA_IMAGE_CAPTURED':
                #     self.log.debug(f"Received CAMERA_IMAGE_CAPTURED ")
                # elif msg.get_type() != 'COMMAND_LONG':
                #     self.log.debug(f"Received message ")
  
            except Exception as e:
                self.log.error(e)
                continue
            # msg = self.master.recv_match(timeout=1)
            if not msg:
                continue
                
        self.log.info("Stopped")
        
    def close(self):
        print(f"Closing {self.__class__.__name__}...")
        self.master.close()
        self.master.port.close()
        # for pipe in self.gstpipes:
        #     pipe.shutdown()
        # self.gstpipes.close()
        self._t_mav_listen_stop = True
        self._t_heartbeat_stop = True
        try:
            self._t_heartbeat.join()
            self._t_mav_listen.join()
        except Exception as e:
            pass

        self.log.info(f"{self.__class__.__name__}  closed")
    
    def __enter__(self):
        """ Context manager entry point for with statement."""
        return self # This value is assigned to the variable after 'as' in the 'with' statement
    
    def __exit__(self, exc_type, exc_value, traceback):
        """Context manager exit point."""
        self.close()
        return False  # re-raise any exceptions
#         
with MavLinkBase("udpout:localhost:14550", debug=True, is_server=True) as server:
    
    pass
time.sleep(0.2)
# 
# with MavLinkBase("udpout:localhost:14550", debug=True, is_server=False) as client:
#     pass
    
