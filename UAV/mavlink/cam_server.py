# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/api/20_mavlink.cam_server.ipynb.

# %% auto 0
__all__ = ['CameraServer']

# %% ../../nbs/api/20_mavlink.cam_server.ipynb 6
import UAV
from ..imports import *   # TODO why is this relative import on nbdev_export?
import cv2

import numpy as np
from imutils import resize

import time

from pathlib import Path
import time
from pymavlink import mavutil
import threading

import logging

import UAV.params as params

import gi
gi.require_version('Gst', '1.0')
from gi.repository import Gst, GObject, GLib

# gi.require_version('Gst', '1.0')

# %% ../../nbs/api/20_mavlink.cam_server.ipynb 7
# logging.basicConfig(format='%(asctime)-8s,%(msecs)-3d %(levelname)5s [%(filename)10s:%(lineno)3d] %(message)s',
#                     datefmt='%H:%M:%S',
#                     level=params.LOGGING_LEVEL)  # Todo add this to params
# logger = logging.getLogger(params.LOGGING_NAME)

# %% ../../nbs/api/20_mavlink.cam_server.ipynb 10
import logging, threading
class CameraServer:
    def __init__(self, connection_string, # "udpin:localhost:14550"
                 baudrate=57600, #baud rate of the serial port
                 camera_id=0, # camera id
                 gstpipes=[]): # list of gstreamer pipelines to control
        self._log = logging.getLogger("uav.{}".format(self.__class__.__name__))
        self.camera_id = camera_id
        # Create the connection
        self.master = mavutil.mavlink_connection(connection_string, baud=baudrate)
        self.gstpipes = gstpipes
        self._t_heartbeat = threading.Thread(target=self.send_heartbeat, daemon=True)
        self._t_heartbeat.start()
        self._t_mav_listen = threading.Thread(target=self.listen, daemon=True)
        self._t_mav_listen.start()
        self.image = None

    def __str__(self) -> str:
        return self.__class__.__name__

    def __repr__(self) -> str:
        return "<{}>".format(self)

    @property
    def log(self) -> logging.Logger:
        return self._log
    
    def send_heartbeat(self):
        """Send a heartbeat message to indicate the server is alive."""
        self._stop_threads = False
        while not self._stop_threads:
            self.master.mav.heartbeat_send(
                mavutil.mavlink.MAV_TYPE_CAMERA,  # type
                # mavutil.mavlink.MAV_TYPE_ONBOARD_CONTROLLER,
                mavutil.mavlink.MAV_AUTOPILOT_INVALID,  # autopilot
                0,  # base_mode
                0,  # custom_mode
                mavutil.mavlink.MAV_STATE_ACTIVE,  # system_status
                3  # MAVLink version
            )
            # print("Cam heartbeat_send")
            time.sleep(1)  # Send every second


    def listen(self):
        """Listen for MAVLink commands and trigger the camera when needed."""
        self._stop_threads = False
        self.log.info("Listening for MAVLink commands...")
        while not self._stop_threads:
            # Wait for a MAVLink message
            try:
                msg = self.master.recv_match(blocking=True, timeout=1)
            except Exception as e:
                self.log.error(e)
                continue
            # msg = self.master.recv_match(timeout=1)
            if not msg:
                continue
            # print (msg)

            # Check if it's a command to control the digital camera
            try:
                if msg.get_type() == 'COMMAND_LONG' and msg.command == mavutil.mavlink.MAV_CMD_DO_DIGICAM_CONTROL:
                    if msg.param2 == 1:  # check if the trigger capture parameter is set
                        self.trigger_camera(msg.param1)
                elif msg.get_type() == 'COMMAND_LONG' and msg.command == mavutil.mavlink.MAV_CMD_VIDEO_START_STREAMING:
                    if msg.param1 >= 1:
                        self.start_streaming(msg.param1)
            except Exception as e:
                self.log.error(e)
                continue
                
        self.log.info("Stopped Thread listening for MAVLink commands")

    def _start_stop_streaming(self, camera_id, dropstate=False):
        # start or stop video stream. 0 = all, 1 = primary camera, 2 secondary, etc.
        self.log.info(f"Camera {camera_id} dropstate: {dropstate}")
        return
        camera_id = int(camera_id-1)  # mavlink camera id starts at 1
        if camera_id >= len(self.gstpipes):
            logger.error(f"Camera {camera_id+1} not found")
        else:
            try:
                if camera_id == -1:
                    for pipe in self.gstpipes:
                        pipe.set_valve_state("myvalve", dropstate)
                else:
                    self.gstpipes[camera_id].set_valve_state("myvalve", dropstate)
            except exception as e:
                logger.error(e)
            
    def start_streaming(self, camera_id):
        # start video stream. 1 = primary camera, 2 secondary, etc.
        self._start_stop_streaming(camera_id, dropstate=False)

    def stop_streaming(self, camera_id):
        # stop video stream. 1 = primary camera, 2 secondary, etc.
        self._start_stop_streaming(camera_id, dropstate=True)    
        
    def trigger_camera(self,  camera_id):
        # Capture an image
        # if video.frame_available():
        #     self.image = video.frame()
            # ax = show_image(image)
            # self.pull_sample(camera_id)
            print(f"Camera triggered! Captured an image {'self.image.shape'}")

    def close(self):
        print("Closing camera server...")
        self.master.close()
        self.master.port.close()
        for pipe in self.gstpipes:
            pipe.shutdown()
        # self.gstpipes.close()
        self._stop_threads = True
        self._t_heartbeat.join()
        self._t_mav_listen.join()
        self.log.info(f"Camera {self.camera_id}  closed")
    
    
    def __enter__(self):
        """ Context manager entry point for with statement."""
        return self # This value is assigned to the variable after 'as' in the 'with' statement
    
    def __exit__(self, exc_type, exc_value, traceback):
        """Context manager exit point."""
        self.close()
        return False  # re-raise any exceptions
        

